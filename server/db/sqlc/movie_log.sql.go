// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: movie_log.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteMovieLogEntry = `-- name: DeleteMovieLogEntry :execrows
DELETE FROM movie_log
WHERE id = $1 AND user_id = $2
`

type DeleteMovieLogEntryParams struct {
	ID     int64 `db:"id" json:"id"`
	UserID int64 `db:"user_id" json:"user_id"`
}

func (q *Queries) DeleteMovieLogEntry(ctx context.Context, arg DeleteMovieLogEntryParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteMovieLogEntry, arg.ID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const listMovieLogByUser = `-- name: ListMovieLogByUser :many
SELECT ml.id AS log_id, ml.user_id, ml.movie_id, mi.original_title, ml.watched_on,
       ml.note, ml.rank_position, ml.created_at, ml.updated_at
FROM movie_log ml
JOIN movie_ids mi ON mi.id = ml.movie_id
WHERE ml.user_id = $1
ORDER BY (ml.rank_position IS NULL), ml.rank_position ASC NULLS LAST, ml.created_at DESC
`

type ListMovieLogByUserRow struct {
	LogID         int64              `db:"log_id" json:"log_id"`
	UserID        int64              `db:"user_id" json:"user_id"`
	MovieID       int32              `db:"movie_id" json:"movie_id"`
	OriginalTitle string             `db:"original_title" json:"original_title"`
	WatchedOn     pgtype.Date        `db:"watched_on" json:"watched_on"`
	Note          pgtype.Text        `db:"note" json:"note"`
	RankPosition  pgtype.Int4        `db:"rank_position" json:"rank_position"`
	CreatedAt     pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) ListMovieLogByUser(ctx context.Context, userID int64) ([]ListMovieLogByUserRow, error) {
	rows, err := q.db.Query(ctx, listMovieLogByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMovieLogByUserRow
	for rows.Next() {
		var i ListMovieLogByUserRow
		if err := rows.Scan(
			&i.LogID,
			&i.UserID,
			&i.MovieID,
			&i.OriginalTitle,
			&i.WatchedOn,
			&i.Note,
			&i.RankPosition,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertMovieLogEntry = `-- name: UpsertMovieLogEntry :one
INSERT INTO movie_log (user_id, movie_id, watched_on, note, rank_position)
VALUES ($1, $2, $3, $4, NULL)
ON CONFLICT (user_id, movie_id) DO UPDATE
SET watched_on = EXCLUDED.watched_on,
    note = EXCLUDED.note,
    updated_at = now()
RETURNING id, user_id, movie_id, watched_on, note, rank_position, created_at, updated_at
`

type UpsertMovieLogEntryParams struct {
	UserID    int64       `db:"user_id" json:"user_id"`
	MovieID   int32       `db:"movie_id" json:"movie_id"`
	WatchedOn pgtype.Date `db:"watched_on" json:"watched_on"`
	Note      pgtype.Text `db:"note" json:"note"`
}

func (q *Queries) UpsertMovieLogEntry(ctx context.Context, arg UpsertMovieLogEntryParams) (MovieLog, error) {
	row := q.db.QueryRow(ctx, upsertMovieLogEntry,
		arg.UserID,
		arg.MovieID,
		arg.WatchedOn,
		arg.Note,
	)
	var i MovieLog
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MovieID,
		&i.WatchedOn,
		&i.Note,
		&i.RankPosition,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
